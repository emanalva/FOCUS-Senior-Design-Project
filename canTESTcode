#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <linux/can.h>
#include <linux/can/raw.h>

int main() {
    int s;
    struct sockaddr_can addr;
    struct ifreq ifr;
    struct can_frame frame;

    // Create a socket
    s = socket(PF_CAN, SOCK_RAW, CAN_RAW);
    if (s < 0) {
        perror("Socket");
        return 1;
    }

    // Specify the CAN interface
    strcpy(ifr.ifr_name, "can0");
    ioctl(s, SIOCGIFINDEX, &ifr);

    // Bind the socket to the CAN interface
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;
    if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        perror("Bind");
        return 1;
    }

    // Prepare a CAN frame
    frame.can_id = 0x123;
    frame.can_dlc = 8;
    for (int i = 0; i < 8; i++) {
        frame.data[i] = i;
    }

    // Send the CAN frame
    if (write(s, &frame, sizeof(struct can_frame)) != sizeof(struct can_frame)) {
        perror("Write");
        return 1;
    }

    close(s);
    return 0;
}
gcc -o can_example can_example.c
./can_example
Pheonixfly1 â€” Today at 6:50 PM
---------------------
#include <SPI.h>
#include <mcp_can.h>

MCP_CAN CAN(17); // CS pin

void setup() {
    Serial.begin(115200);
    while (CAN_OK != CAN.begin(CAN_500KBPS)) {
        Serial.println("CAN init fail, Retry...");
        delay(100);
    }
    Serial.println("CAN init OK!");
}

void loop() {
    long unsigned int rxId;
    unsigned char len = 0;
    unsigned char buf[8];

    // Read data from encoder (you need to implement this part)
    int encoderValue = readEncoder();

    // Send CAN message
    CAN.sendMsgBuf(0x100, 0, 4, (byte)&encoderValue);

    // Receive CAN message
    if (CAN_MSGAVAIL == CAN.checkReceive()) {
        CAN.readMsgBuf(&rxId, &len, buf);
        // Handle incoming data from Raspberry Pi
        int receivedData =((int*)buf);
        // Process the received data
    }
    delay(100); // Adjust for your needs
}

int readEncoder() {
    // Implement your encoder reading logic here
    return 0; // Placeholder
}



----RASPBERRYPI
import can

def main():
    bus = can.interface.Bus(channel='can0', bustype='socketcan')

    while True:
        message = bus.recv()
        if message:
            print(f'Received message: {message.data}')
            # You can send a response back if needed

if __name__ == __"main"__:
    main()
